# 缓存穿透

#### 含义：

即需要查询的数据在缓存中没有，必须要去数据库查询，如果查询的数据每次都在缓存中找不到，每次都需要在数据库查询，那么这样就会十分消耗性能，如果查询过度，甚至有可能导致mysql数据库瘫痪

#### 解决方法

**一、以不存在为数据为键，null为值**

​	在查询过程中，为每一个不存在的数据，添加一个null的值，并且放置在缓存中。

这种应对单一的不存在数据效果比较好

​	但是如果不存在的数据量过多，则需要为每一个不存在的数据都设置null值，并且放置在内存中。那么就会使得内存占用率升高，导致内存紧张，并且也会导致redis根据自己的缓存淘汰算法将热点数据淘汰掉，这样是不得尝试的。

​	最主要的原因就是将热点数据淘汰

**二、使用过滤器来进行判断查询的键是否存在**

​	将查询的所有数据库的关键字全部放在这个过滤器中。比如，如果是使用id作为关键字查询，那么就需要将数据库所有id全部缓存在过滤器中。

​	这样虽然不至于使得redis热点数据丢失，并且还可以阻挡不存在键值的查询。

​	但是如果这个关键字是name的话，就会使得内存占用率升高。

**三、使用布隆算法**

​	布隆算法是以错误率来换取内存占用的

​	基本思想是：将数据库的对应全部关键字加以哈希函数计算得到哈希值，并将对应数组位置置为1，表示存在。【而错误率的产生就是因为：一个值的计算出的哈希值在对应数组为1，并不一定代表存在该数据，但是对应数组为0，那么就一定不存在该数据】

​	它的错误率和什么有关系：

​		1、数组长度：数组长度过多，就会导致内存占用上升。但是数组过短，错误率就会升高

​		2、hash函数的个数：如果使用多个hash函数加以计算，取多个hash函数的交集，只有多个hash函数同时计算的值对应数组位置是1，才代表存在。这样也可以降低错误率。但是请注意hash函数的个数很多，也会导致错误率升高，因为数组只有一条。

**所以，在使用的过程中，最好取得数组大小和hash函数个数的平均值**

​	如何通过错误率来计算数组应有长度和hash函数个数

​		根据误判率fbb和数据量n，bit数组大小m计算方式：

```
m = - nln(fpp)/((ln2)^2)
```

​		根据数据量n以及bit数组长度n，来找到hash函数的个数k：
```
k = (m/n)ln2
```
# 缓存雪崩

当在redis的数据【一堆】失效时，那么请求这些数据的请求就会全部去到mysql进行请求

# 缓存击穿

当在redis的数据【一条】失效时，那么请求数据的请求就会全部去到mysql进行请求





失效即是达到了有效期

缓存雪崩和缓存击穿只是缓存穿透的一种特殊形式